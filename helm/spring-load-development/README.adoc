= Spring Load Development - Helm Chart
:toc: left
:toclevels: 3
:sectlinks:
:sectanchors:
:source-highlighter: highlight.js
:icons: font

This Helm chart deploys the complete Spring Load Development application stack on Kubernetes using a modular subchart architecture, providing a production-ready foundation for the reloading management system.

== Overview

The Helm chart uses a **modular subchart architecture** with 4 independent subcharts:

* *Observability Subchart* - Loki, Tempo, Prometheus, Grafana, and OpenTelemetry Collector for monitoring and tracing
* *Keycloak Subchart* - Authentication and authorization server with dedicated PostgreSQL database and realm configuration  
* *PostgreSQL Subchart* - Separate database instances for microservices and Keycloak
* *Reloading Subchart* - Spring Boot microservices (API Gateway, Loads Service, Components Service, Rifles Service, and MCP Server)

Each subchart can be enabled/disabled independently and configured separately, providing maximum flexibility and maintainability.

=== Excluded Core Services

This chart intentionally omits Spring Cloud *Config Server*, *Discovery (Eureka) Server*, and *Spring Boot Admin* for simplicity and faster local cluster startup. In production you may:

* Deploy Config Server separately (or migrate to native Kubernetes ConfigMaps/Secrets)
* Use service discovery via Kubernetes DNS (rendering Eureka optional)
* Run Spring Boot Admin externally or rely on Grafana + Actuator endpoints

To add these, extend `values.yaml` and duplicate a microservice stanza in `microservices.yaml` using the existing helper templates.

=== Externalized Configuration

Application configuration (profiles, ports, Keycloak, logging) is sourced from the separate Git repository:

https://github.com/zhoozhoo/spring-load-development-config

Key files in that repository map directly to services:

* `application.yml` – shared defaults consumed by all services via Config Server
* `api-gateway.yml`, `loads-service.yml`, `rifles-service.yml`, `components-service.yml`, `mcp-server.yml` – service‑specific overrides
* `discovery-server.yml`, `admin-server.yml` – infrastructure service settings
* `log4j2.xml` / `log4j2.yaml` – centralized logging configuration

When deploying with this Helm chart (which excludes Config Server/Eureka), you can either:

1. Bake required properties into container images (environment variables / Spring Boot `SPRING_` bindings)
2. Create ConfigMaps & Secrets from the above YAMLs and mount/translate them to env vars
3. Add a lightweight Spring Cloud Config Server Deployment referencing the config repo (recommended if frequent changes)

Example (create ConfigMap from `api-gateway.yml`):

[source,bash]
----
kubectl create configmap api-gateway-config \
  --from-file=api-gateway.yml=../spring-load-development-config/api-gateway.yml \
  -n reloading
----

Then reference in `values.yaml` via an env var section:

[source,yaml]
----
apiGateway:
  extraEnv:
    - name: SPRING_CONFIG_IMPORT
      value: optional:file:/config/api-gateway.yml
  extraVolumeMounts:
    - name: app-config
      mountPath: /config
  extraVolumes:
    - name: app-config
      configMap:
        name: api-gateway-config
----

=== Application Services

The chart includes the following Spring Boot microservices:

* *API Gateway* (`spring-loaddev-api-gateway`) - Main entry point and routing service
* *Loads Service* (`spring-loaddev-loads-service`) - Load data management service  
* *Components Service* (`spring-loaddev-components-service`) - Component management service
* *Rifles Service* (`rifles-service`) - Rifle data management service
* *MCP Server* (`spring-loaddev-mcp-server`) - Model Context Protocol server

== Architecture

[source,mermaid]
....
flowchart LR
  subgraph Databases
    PG1[(PostgreSQL loadsdb)]
    PG2[(PostgreSQL keycloak)]
  end
  subgraph Auth
    KC[Keycloak]
  end
  subgraph Microservices
    GW[API Gateway\nNodePort 30090]
    LS[Loads Service]
    CS[Components Service]
    RS[Rifles Service]
    MCP[MCP Server]
  end
  subgraph Observability
    OTEL[OTel Collector]
    LOKI[Loki]
    TEMPO[Tempo]
    PROM[Prometheus]
    GRAF[Grafana\nNodePort 30000]
  end
  USER[User]
  GW --> LS & CS & RS & MCP
  PG1 --> LS & CS & RS & MCP
  PG2 --> KC
  GW --> KC
  LS --> KC
  CS --> KC
  RS --> KC
  MCP --> KC
  GW --> OTEL
  LS --> OTEL
  CS --> OTEL
  RS --> OTEL
  MCP --> OTEL
  KC --> OTEL
  OTEL --> LOKI & TEMPO & PROM
  PROM --> GRAF
  LOKI --> GRAF
  TEMPO --> GRAF
  USER --> GW
  USER --> KC
  USER --> GRAF
  classDef db fill:#e1f5fe,stroke:#388e3c,stroke-width:2px
  classDef auth fill:#fff3e0,stroke:#f57c00,stroke-width:2px
  classDef svc fill:#e8f5e8,stroke:#388e3c,stroke-width:2px
  classDef obs fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
  classDef user fill:#ffebee,stroke:#c62828,stroke-width:2px
  class PG1,PG2 db
  class KC auth
  class GW,LS,CS,RS,MCP svc
  class OTEL,LOKI,TEMPO,PROM,GRAF obs
  class USER user
....

== Quick Start

=== Prerequisites

* Kubernetes cluster (Docker Desktop, minikube, or cloud provider)
* Helm 3.x installed
* kubectl configured
* Cluster admin permissions to create namespaces

=== Deploy with Subcharts

[source,bash]
----
# Clone the repository
git clone <your-repo-url>
cd spring-load-development/helm/spring-load-development

# Step 1: Update subchart dependencies
helm dependency update

# Step 2: Create required namespaces
# The chart requires 4 namespaces: postgres, keycloak, observability, reloading
./create-namespaces.sh

# Or create them manually:
# kubectl create namespace postgres
# kubectl create namespace keycloak
# kubectl create namespace observability
# kubectl create namespace reloading

# Step 3: Deploy the complete stack
helm install spring-load-development . \
  --values values.yaml \
  --create-namespace \
  --namespace reloading \
  --timeout 300s

# Or upgrade if already installed
helm upgrade spring-load-development . \
  --values values.yaml \
  --namespace reloading \
  --timeout 300s
----

NOTE: The `helm dependency update` command downloads and packages the subcharts. This step is required before first installation.

=== Access Services

==== NodePort Access (Docker Desktop/Local)

* *Grafana*: http://localhost:30000 (anonymous access enabled)
* *Keycloak*: http://localhost:30080 (admin/admin)
* *API Gateway*: http://localhost:30090 (main application entry point)
* *Prometheus*: http://localhost:30091
* *Loki*: http://localhost:30100
* *Tempo*: http://localhost:30200
* *OpenTelemetry Collector GRPC*: localhost:30317
* *OpenTelemetry Collector Metrics*: http://localhost:30889

==== Port Forward Access

[source,bash]
----
# Grafana
kubectl port-forward svc/grafana-service 3000:3000 -n observability

# Keycloak  
kubectl port-forward svc/keycloak-service 8080:8080 -n keycloak

# API Gateway
kubectl port-forward svc/api-gateway 8080:8080 -n reloading

# Individual microservices
kubectl port-forward svc/loads-service 8081:8080 -n reloading
kubectl port-forward svc/components-service 8082:8080 -n reloading
kubectl port-forward svc/rifles-service 8083:8080 -n reloading
kubectl port-forward svc/mcp-server-service 8084:8080 -n reloading
----

== Components

=== PostgreSQL Databases

Both PostgreSQL instances use *StatefulSets* for stable network identity and persistent storage management. This provides:

* Stable, unique network identifiers
* Stable, persistent storage that survives pod rescheduling
* Ordered, graceful deployment and scaling
* Ordered, automated rolling updates
* Foundation for future HA configurations

==== Microservices Database

* *Resource Type*: StatefulSet
* *Namespace*: `postgres`
* *Service*: `postgres-service.postgres.svc.cluster.local:5432`
* *Database*: `loadsdb`
* *Credentials*: `user` / `password`
* *Storage*: 8Gi persistent volume (managed by volumeClaimTemplates)
* *Version*: PostgreSQL 18.1
* *Replicas*: 1 (configurable via `postgresql.replicas`)
* *Purpose*: For Spring Boot microservices data storage

==== Keycloak Database

* *Resource Type*: StatefulSet
* *Namespace*: `keycloak`
* *Service*: `keycloak-postgres-service.keycloak.svc.cluster.local:5432`
* *Database*: `keycloak`
* *Credentials*: `user` / `password`
* *Storage*: 8Gi persistent volume (managed by volumeClaimTemplates)
* *Version*: PostgreSQL 18.1
* *Replicas*: 1 (configurable via `keycloakPostgresql.replicas`)
* *Purpose*: Dedicated for Keycloak authentication data

NOTE: StatefulSets provide better guarantees for database workloads compared to Deployments. The persistent storage follows the pod lifecycle and is automatically reattached if the pod is rescheduled.

=== Keycloak Authentication Server

* *Version*: 26.4
* *Namespace*: `keycloak`
* *Admin Console*: http://localhost:30080
* *Admin Credentials*: `admin` / `admin`
* *Realm*: `reloading`
* *Client ID*: `reloading-client`
* *Features*:
** PostgreSQL backend with dedicated database
** Realm import enabled with custom realm configuration
** OpenTelemetry tracing to Tempo
** Health checks enabled
** Development mode for local testing
** Integration with API Gateway and microservices

=== Spring Boot Microservices

==== API Gateway

* *Image*: `zhoozhoo.ca/spring-load-development/spring-loaddev-api-gateway:0.1.0-SNAPSHOT`
* *Namespace*: `reloading`
* *Service*: `api-gateway.reloading.svc.cluster.local:8080`
* *NodePort*: 30090
* *Purpose*: Main entry point, routing, and load balancing for all microservices
* *Resources*: CPU 500m-1000m, Memory 512Mi-1Gi

==== Loads Service

* *Image*: `zhoozhoo.ca/spring-load-development/spring-loaddev-loads-service:0.1.0-SNAPSHOT`
* *Namespace*: `reloading`
* *Service*: `loads-service.reloading.svc.cluster.local:8080`
* *Purpose*: Manages load data and calculations
* *Resources*: CPU 250m-500m, Memory 256Mi-512Mi

==== Components Service

* *Image*: `zhoozhoo.ca/spring-load-development/spring-loaddev-components-service:0.1.0-SNAPSHOT`
* *Namespace*: `reloading`
* *Service*: `components-service.reloading.svc.cluster.local:8080`
* *Purpose*: Manages reloading components (cases, propellants/powders, primers, projectiles/bullets) with full-text search
* *Resources*: CPU 250m-500m, Memory 256Mi-512Mi

==== Rifles Service

* *Image*: `zhoozhoo.ca/spring-load-development/rifles-service:0.1.0-SNAPSHOT`
* *Namespace*: `reloading`
* *Service*: `rifles-service.reloading.svc.cluster.local:8080`
* *Purpose*: Manages rifle and firearm data
* *Resources*: CPU 250m-500m, Memory 256Mi-512Mi

==== MCP Server

* *Image*: `zhoozhoo.ca/spring-load-development/spring-loaddev-mcp-server:0.1.0-SNAPSHOT`
* *Namespace*: `reloading`
* *Service*: `mcp-server-service.reloading.svc.cluster.local:8080`
* *Purpose*: Model Context Protocol server for AI integrations
* *Resources*: CPU 250m-500m, Memory 256Mi-512Mi

=== Observability Stack

==== Loki (Log Aggregation)

* *Version*: 3.5.8
* *Namespace*: `observability`
* *Port*: 30100
* *Storage*: Filesystem with 10Gi persistent volume
* *Retention*: 6 hours
* *Purpose*: Centralized log collection and querying

==== Tempo (Distributed Tracing)

* *Version*: 2.9.0
* *Port*: 30200
* *Storage*: Local filesystem with 10Gi persistent volume
* *Features*: OTLP receivers, metrics generation, trace querying

==== Prometheus (Metrics)

* *Version*: v3.7.3
* *Namespace*: `observability`
* *Port*: 30091
* *Storage*: 10Gi persistent volume
* *Retention*: 24 hours
* *Scrape Targets*: OpenTelemetry Collector metrics

==== Grafana (Visualization)

* *Version*: 12.3.1
* *Port*: 30000
* *Authentication*: Anonymous access enabled (Admin role)
* *Datasources*: Pre-configured Loki, Tempo, and Prometheus
* *Features*:
** Cross-datasource correlation (traces ↔ metrics ↔ logs)
** Exemplar support for trace sampling
** 5Gi persistent storage

==== OpenTelemetry Collector

* *Version*: 0.142.0
* *Namespace*: `observability`
* *GRPC Port*: 30317
* *Metrics Port*: 30889
* *Purpose*:
** Collect telemetry from applications
** Export logs to Loki via OTLP HTTP
** Export traces to Tempo via OTLP
** Export metrics to Prometheus
** Health checks and monitoring
** Filter out actuator endpoints and internal spans

== Configuration

=== Version Management (Single Source of Truth)

All container versions are centrally managed in the parent chart's `values.yaml` under `global.versions`. This provides a **single source of truth** for all image versions across all subcharts:

[source,yaml]
----
global:
  imageRegistry: "zhoozhoo.ca"
  imageTag: "0.1.0-SNAPSHOT"
  
  # Single source of truth for all container versions
  versions:
    # Spring Boot microservices
    microservices: "0.1.0-SNAPSHOT"
    
    # Observability stack
    loki: "3.6.3"
    tempo: "2.9.0"
    prometheus: "v3.8.1"
    grafana: "12.3.1"
    otelCollector: "0.142.0"
    
    # Identity and database
    keycloak: "26.4"
    postgresql: "18.1"
----

To upgrade all microservices to a new version, simply change `global.versions.microservices`:

[source,bash]
----
# Upgrade all microservices to version 1.0.0
helm upgrade spring-load-development . \
  --set global.versions.microservices=1.0.0

# Upgrade specific observability component
helm upgrade spring-load-development . \
  --set global.versions.grafana=13.0.0
----

Individual subchart `values.yaml` files still contain version tags as fallbacks, but the parent chart's `global.versions` always takes precedence. This ensures:

* **Consistency** - All services use the same version without duplicate configuration
* **Simplicity** - Single place to update versions for deployment
* **Flexibility** - Individual subcharts can still be used standalone with their own defaults

=== Modular Subchart Configuration

The chart uses a modular configuration structure where each subchart has its own `values.yaml`. The parent chart's `values.yaml` controls which subcharts are enabled and overrides their values:

[source,yaml]
----
# Parent values.yaml - Global settings and subchart control

# Global settings shared across all subcharts
global:
  imageRegistry: "zhoozhoo.ca"
  imageTag: "latest"

# Enable/disable entire subcharts
observability:
  enabled: true               # Enable/disable complete observability stack
  namespace: observability
  observability:             # Subchart-specific values (nested)
    # Override subchart values here

keycloak:
  enabled: true               # Enable/disable Keycloak authentication
  namespace: keycloak
  keycloak:                  # Subchart-specific values (nested)
    # Override subchart values here

postgresql:
  enabled: true               # Enable/disable PostgreSQL databases
  postgresql:                # Subchart-specific values (nested)
    namespace: postgres
    # Override subchart values here

reloading:
  enabled: true               # Enable/disable microservices
  namespace: reloading
  # Microservice configurations here
  apiGateway:
    enabled: true
    replicas: 1
    service:
      nodePort: 30090
  loadsService:
    enabled: true
  componentsService:
    enabled: true
  riflesService:
    enabled: true
  mcpServer:
    enabled: true
----

=== Subchart Structure

Each subchart has its own independent configuration:

* `charts/observability/values.yaml` - Loki, Tempo, Prometheus, Grafana, OTEL Collector settings
* `charts/keycloak/values.yaml` - Keycloak authentication and realm configuration
* `charts/postgresql/values.yaml` - PostgreSQL database settings for both instances
* `charts/reloading/values.yaml` - All microservice configurations

=== Customizing Subchart Configuration

==== Disable Specific Subcharts

[source,yaml]
----
# Disable observability stack for development
observability:
  enabled: false

# Disable Keycloak if using external auth
keycloak:
  enabled: false

# Run only infrastructure (no microservices)
reloading:
  enabled: false
----

==== Override Subchart Values

[source,yaml]
----
# Override observability storage sizes
observability:
  enabled: true
  observability:
    loki:
      persistence:
        size: 50Gi
    tempo:
      persistence:
        size: 100Gi
    prometheus:
      persistence:
        size: 25Gi

# Override PostgreSQL configuration
postgresql:
  enabled: true
  postgresql:
    persistence:
      size: 20Gi
    auth:
      password: "mysecurepassword"

# Scale microservices in reloading subchart
reloading:
  enabled: true
  apiGateway:
    replicas: 2
    resources:
      limits:
        cpu: 2000m
        memory: 2Gi
  loadsService:
    replicas: 3
    resources:
      limits:
        cpu: 1000m
        memory: 1Gi
----

==== External Access Ports

[source,yaml]
----
# Change NodePort ranges
apiGateway:
  service:
    nodePort: 30090      # API Gateway entry point

keycloak:
  nodePort:
    port: 30080         # Keycloak admin console

observability:
  grafana:
    nodePort:
      port: 30000       # Grafana dashboard
  prometheus:
    nodePort:
      port: 30091       # Prometheus UI
  loki:
    nodePort:
      port: 30100       # Loki API
  tempo:
    nodePort:
      port: 30200       # Tempo API
  otelCollector:
    nodePort:
      grpcPort: 30317   # OTEL GRPC
      prometheusPort: 30889  # OTEL Metrics
----

==== Keycloak Configuration

[source,yaml]
----
keycloak:
  auth:
    adminUser: myadmin        # Change admin username
    adminPassword: mysecret   # Change admin password
  realm:
    enabled: false           # Disable realm import
  integration:
    realm: "mycustomrealm"   # Custom realm name
    clientId: "myclient"     # Custom client ID
    clientSecret: "newsecret" # Custom client secret
----

== Deployment

=== Standard Deployment

[source,bash]
----
# Deploy infrastructure
helm install spring-load-development . \
  --values values.yaml \
  --create-namespace \
  --timeout 300s
----

=== Custom Configuration

[source,bash]
----
# Create custom values
cp values.yaml values-custom.yaml
# Edit values-custom.yaml as needed

# Deploy with custom configuration
helm install spring-load-development . \
  --values values-custom.yaml \
  --create-namespace \
  --timeout 300s
----

=== Upgrade Existing Installation

[source,bash]
----
# Upgrade infrastructure
helm upgrade spring-load-development . \
  --values values.yaml \
  --timeout 300s
----

== Database Access

=== Microservices PostgreSQL

[source,bash]
----
# Connect to database
kubectl exec -it postgres-0 -n postgres -- psql -U user -d loadsdb

# Port forward for external access
kubectl port-forward postgres-0 5432:5432 -n postgres
----

=== Keycloak PostgreSQL

[source,bash]
----
# Connect to Keycloak database
kubectl exec -it keycloak-postgres-0 -n keycloak -- psql -U user -d keycloak

# Port forward for external access
kubectl port-forward keycloak-postgres-0 5433:5432 -n keycloak
----

== Monitoring and Observability

=== Grafana Dashboards

* *Access*: http://localhost:30000
* *Authentication*: Anonymous (Admin role)
* *Pre-configured datasources*: Loki, Tempo, Prometheus
* *Cross-datasource correlation*: Click trace IDs in logs to view in Tempo

=== Log Aggregation (Loki)

[source,bash]
----
# Access Loki directly
curl http://localhost:30100/ready

# Query logs via API
curl 'http://localhost:30100/loki/api/v1/query?query={container="keycloak"}'
----

=== Distributed Tracing (Tempo)

[source,bash]
----
# Access Tempo directly
curl http://localhost:30200/status

# Send traces to OpenTelemetry Collector
# Applications should export to: http://otel-collector:4317
----

=== Metrics (Prometheus)

[source,bash]
----
# Access Prometheus UI
open http://localhost:30091

# Query metrics
curl 'http://localhost:30091/api/v1/query?query=up'
----

== Application Integration

=== PostgreSQL Connection (Microservices)

[source,yaml]
----
# Spring Boot application.yml
spring:
  r2dbc:
    url: r2dbc:postgresql://postgres-service.postgres.svc.cluster.local:5432/loadsdb
    username: user
    password: password
  
  # Or for traditional JDBC
  datasource:
    url: jdbc:postgresql://postgres-service.postgres.svc.cluster.local:5432/loadsdb
    username: user
    password: password
----

=== OpenTelemetry Configuration

[source,yaml]
----
# Send telemetry to collector
otel:
  exporter:
    otlp:
      endpoint: http://otel-collector-service.observability.svc.cluster.local:4317
  resource:
    attributes:
      service.name: loads-service
      service.version: 0.0.8-SNAPSHOT
      service.environment: kubernetes

# Spring Boot specific configuration
management:
  otlp:
    tracing:
      endpoint: http://otel-collector-service.observability.svc.cluster.local:4317
----

=== Keycloak Integration

[source,yaml]
----
# Spring Security OAuth2 configuration
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://keycloak-service.keycloak.svc.cluster.local:8080/realms/reloading
      client:
        registration:
          reloading-client:
            client-id: reloading-client
            client-secret: 2EvQuluZfxaaRms8V4NhzBDWzVCSXtty
            authorization-grant-type: authorization_code
            redirect-uri: "{baseUrl}/login/oauth2/code/{registrationId}"
            scope: openid,profile,email
        provider:
          keycloak:
            issuer-uri: http://keycloak-service.keycloak.svc.cluster.local:8080/realms/reloading
----

=== Service-to-Service Communication

[source,yaml]
----
# API Gateway routes configuration
spring:
  cloud:
    gateway:
      routes:
        - id: loads-service
          uri: http://loads-service.reloading.svc.cluster.local:8080
          predicates:
            - Path=/api/loads/**
        - id: components-service
          uri: http://components-service.reloading.svc.cluster.local:8080
          predicates:
            - Path=/api/components/**
        - id: rifles-service
          uri: http://rifles-service.reloading.svc.cluster.local:8080
          predicates:
            - Path=/api/rifles/**
        - id: mcp-server
          uri: http://mcp-server-service.reloading.svc.cluster.local:8080
          predicates:
            - Path=/api/mcp/**
----

== Troubleshooting

=== Common Issues

==== PostgreSQL Connection Issues

[source,bash]
----
# Check PostgreSQL status
kubectl get pods -n postgres
kubectl logs postgres-0 -n postgres

# Check service DNS resolution
kubectl run test-pod --image=busybox --rm -it -- nslookup postgres-service.postgres.svc.cluster.local
----

==== Keycloak Admin Login Issues

[source,bash]
----
# Check Keycloak logs
kubectl logs deployment/keycloak -n keycloak

# Verify admin user creation
kubectl exec -it deployment/keycloak -n keycloak -- cat /opt/keycloak/conf/keycloak.conf

# Reset Keycloak database if needed
kubectl delete pvc keycloak-postgres-pvc -n keycloak
helm upgrade spring-load-development . --values values.yaml
----

==== Observability Stack Issues

[source,bash]
----
# Check all observability components
kubectl get all -n observability

# Test OpenTelemetry Collector
kubectl port-forward svc/otel-collector 4317:4317 -n observability
# Send test trace to localhost:4317

# Check Grafana datasources
curl http://localhost:30000/api/datasources
----

=== Health Checks

[source,bash]
----
# Check all component health
kubectl get pods --all-namespaces | grep -E "(postgres|keycloak|grafana|loki|tempo|prometheus|otel)"

# Detailed pod status
kubectl describe pod <pod-name> -n <namespace>

# Component logs
kubectl logs <pod-name> -n <namespace> -f
----

=== Port Forward Everything

[source,bash]
----
# Forward all services for testing
kubectl port-forward svc/grafana-service 3000:3000 -n observability &
kubectl port-forward svc/keycloak-service 8080:8080 -n keycloak &
kubectl port-forward svc/prometheus-service 9090:9090 -n observability &
kubectl port-forward svc/loki-service 3100:3100 -n observability &
kubectl port-forward svc/tempo-service 3200:3200 -n observability &
kubectl port-forward postgres-0 5432:5432 -n postgres &
kubectl port-forward keycloak-postgres-0 5433:5432 -n keycloak &
----

=== Reset Infrastructure

[source,bash]
----
# Complete reset (deletes all data)
helm uninstall spring-load-development
kubectl delete namespace postgres keycloak observability reloading
kubectl delete pvc --all --all-namespaces

# Redeploy
helm install spring-load-development . --values values.yaml --create-namespace --timeout 300s
----

== Development and Testing

=== Local Development Setup

[source,bash]
----
# Deploy only infrastructure (no microservices)
helm install spring-load-development . \
  --values values.yaml \
  --set apiGateway.enabled=false \
  --set loadsService.enabled=false \
  --set componentsService.enabled=false \
  --set riflesService.enabled=false \
  --set mcpServer.enabled=false \
  --create-namespace

# Run microservices locally pointing to cluster infrastructure
export POSTGRES_URL=jdbc:postgresql://localhost:5432/loadsdb
export KEYCLOAK_URL=http://localhost:30080/realms/reloading
export OTEL_ENDPOINT=http://localhost:30317
kubectl port-forward postgres-0 5432:5432 -n postgres &
----

=== Testing Individual Services

[source,bash]
----
# Test API Gateway
curl http://localhost:30090/actuator/health

# Test individual services through API Gateway
curl http://localhost:30090/api/loads/health
curl http://localhost:30090/api/components/health
curl http://localhost:30090/api/rifles/health
curl http://localhost:30090/api/mcp/health

# Direct service testing (port forward required)
kubectl port-forward svc/loads-service 8081:8080 -n reloading
curl http://localhost:8081/actuator/health
----

== Scaling and Production

=== Resource Adjustments

[source,yaml]
----
# Increase replicas for high availability
postgresql:
  replicas: 3

keycloak:
  replicas: 2

# Scale microservices  
apiGateway:
  replicas: 2
  resources:
    limits:
      cpu: 2000m
      memory: 2Gi

loadsService:
  replicas: 3
  resources:
    limits:
      cpu: 1000m
      memory: 1Gi

# Increase observability resources
observability:
  prometheus:
    resources:
      limits:
        cpu: 2000m
        memory: 4Gi
  grafana:
    resources:
      limits:
        cpu: 1000m
        memory: 2Gi
----

=== Backup Strategy

[source,bash]
----
# PostgreSQL backup
kubectl exec postgres-0 -n postgres -- pg_dump -U user loadsdb > backup-microservices.sql
kubectl exec keycloak-postgres-0 -n keycloak -- pg_dump -U user keycloak > backup-keycloak.sql

# Application-specific data backup
kubectl exec postgres-0 -n postgres -- pg_dump -U user -t loads loadsdb > backup-loads.sql
kubectl exec postgres-0 -n postgres -- pg_dump -U user -t components loadsdb > backup-components.sql
kubectl exec postgres-0 -n postgres -- pg_dump -U user -t rifles loadsdb > backup-rifles.sql

# Persistent volume snapshots (cloud providers)
kubectl get pvc --all-namespaces

# Configuration backup
kubectl get configmap keycloak-realm-config -n keycloak -o yaml > keycloak-realm-backup.yaml
----

=== Security Hardening

* Change default passwords in production
* Enable TLS for all services  
* Configure network policies for namespace isolation
* Use proper RBAC with least privilege access
* Enable audit logging
* Use image scanning and signed images
* Configure pod security policies
* Use secrets management for sensitive data

== Chart Information

* *Chart Version*: 0.1.0-SNAPSHOT
* *App Version*: 0.1.0-SNAPSHOT
* *Maintainer*: Zhubin Salehi (zhoozhoo@yahoo.com)
* *Kubernetes Version*: 1.24+
* *Helm Version*: 3.x
* *Dependencies*: None (all components included)
* *Namespaces*: `postgres`, `keycloak`, `observability`, `reloading`

== Chart Structure

This Helm chart follows modern best practices with a **modular subchart architecture** featuring subcharts and sub-subcharts for maximum modularity.

=== Folder Structure

[source,text]
----
spring-load-development/
├── Chart.yaml                    # Parent chart metadata with subchart dependencies
├── Chart.lock                    # Dependency lock file (generated, committed)
├── values.yaml                   # Simplified parent configuration
├── values.schema.json           # JSON Schema validation
├── .helmignore                  # Helm packaging exclusions
├── README.adoc                  # This documentation
├── create-namespaces.sh         # Namespace creation script
├── templates/                   # Parent chart templates
│   ├── _helpers.tpl            # Parent helper functions
│   └── NOTES.txt               # Post-installation instructions
└── charts/                      # Subcharts directory
    ├── observability/           # Observability subchart
    │   ├── Chart.yaml          # Observability metadata with sub-subchart dependencies
    │   ├── values.yaml         # Enable/disable flags for sub-subcharts
    │   ├── templates/          # Observability shared templates
    │   │   └── _helpers.tpl   # Observability helper functions
    │   └── charts/             # Observability sub-subcharts
    │       ├── grafana/        # Grafana sub-subchart
    │       │   ├── Chart.yaml  # Version: 0.1.0-SNAPSHOT, AppVersion: 12.3.1
    │       │   ├── values.yaml # Grafana-specific configuration
    │       │   └── templates/
    │       │       ├── _helpers.tpl      # Grafana helper functions
    │       │       ├── configmap.yaml    # Grafana configuration & datasources
    │       │       ├── deployment.yaml   # Grafana deployment
    │       │       ├── ingress.yaml      # Grafana ingress
    │       │       ├── pdb.yaml          # PodDisruptionBudget
    │       │       ├── pvc.yaml          # Persistent storage
    │       │       └── service.yaml      # Grafana service with NodePort 30000
    │       ├── loki/            # Loki sub-subchart
    │       │   ├── Chart.yaml   # Version: 0.1.0-SNAPSHOT, AppVersion: 3.6.3
    │       │   ├── values.yaml  # Loki-specific configuration
    │       │   └── templates/
    │       │       ├── _helpers.tpl      # Loki helper functions
    │       │       ├── configmap.yaml    # Loki configuration
    │       │       ├── deployment.yaml   # Loki deployment
    │       │       ├── pdb.yaml          # PodDisruptionBudget
    │       │       ├── pvc.yaml          # Persistent storage
    │       │       └── service.yaml      # Loki service with NodePort 30100
    │       ├── otel-collector/  # OpenTelemetry Collector sub-subchart
    │       │   ├── Chart.yaml   # Version: 0.1.0-SNAPSHOT, AppVersion: 0.142.0
    │       │   ├── values.yaml  # OTel Collector configuration
    │       │   └── templates/
    │       │       ├── _helpers.tpl      # OTel Collector helper functions
    │       │       ├── configmap.yaml    # OTel pipeline configuration
    │       │       ├── deployment.yaml   # OTel Collector deployment
    │       │       ├── pdb.yaml          # PodDisruptionBudget
    │       │       └── service.yaml      # OTel service (GRPC 30317, HTTP 30889)
    │       ├── prometheus/      # Prometheus sub-subchart
    │       │   ├── Chart.yaml   # Version: 0.1.0-SNAPSHOT, AppVersion: v3.8.1
    │       │   ├── values.yaml  # Prometheus-specific configuration
    │       │   └── templates/
    │       │       ├── _helpers.tpl      # Prometheus helper functions
    │       │       ├── configmap.yaml    # Prometheus scrape configs
    │       │       ├── deployment.yaml   # Prometheus deployment
    │       │       ├── pdb.yaml          # PodDisruptionBudget
    │       │       ├── pvc.yaml          # Persistent storage
    │       │       └── service.yaml      # Prometheus service with NodePort 30091
    │       └── tempo/           # Tempo sub-subchart
    │           ├── Chart.yaml   # Version: 0.1.0-SNAPSHOT, AppVersion: 2.9.0
    │           ├── values.yaml  # Tempo-specific configuration
    │           └── templates/
    │               ├── _helpers.tpl      # Tempo helper functions
    │               ├── configmap.yaml    # Tempo configuration
    │               ├── deployment.yaml   # Tempo deployment
    │               ├── pdb.yaml          # PodDisruptionBudget
    │               ├── pvc.yaml          # Persistent storage
    │               └── service.yaml      # Tempo service with NodePort 30200
    ├── keycloak/                # Keycloak subchart
    │   ├── Chart.yaml           # Keycloak metadata
    │   ├── values.yaml          # Keycloak configuration
    │   ├── files/
    │   │   └── realm.json       # Keycloak realm definition
    │   └── templates/
    │       ├── _helpers.tpl             # Keycloak helper functions
    │       ├── configmap.yaml           # Keycloak configuration
    │       ├── deployment.yaml          # Keycloak deployment with realm import
    │       ├── ingress.yaml             # Keycloak ingress
    │       ├── poddisruptionbudget.yaml # Keycloak PDB
    │       ├── realm-configmap.yaml     # Realm import ConfigMap
    │       ├── secret.yaml              # Keycloak secrets
    │       └── service.yaml             # Keycloak service
    ├── postgresql/              # PostgreSQL subchart
    │   ├── Chart.yaml           # PostgreSQL metadata
    │   ├── values.yaml          # PostgreSQL configuration (2 instances)
    │   └── templates/
    │       ├── _helpers.tpl             # Database helper functions
    │       ├── configmap.yaml           # PostgreSQL configuration
    │       ├── poddisruptionbudgets.yaml # PDBs for both databases
    │       ├── secret.yaml              # Database secrets
    │       ├── service.yaml             # Database services
    │       └── statefulset.yaml         # 2 StatefulSets
    └── reloading/               # Spring Boot microservices subchart
        ├── Chart.yaml           # Reloading metadata
        ├── values.yaml          # All microservice configurations
        └── templates/
            ├── _helpers.tpl             # Microservice helper functions
            ├── configmaps.yaml          # Spring Boot configs, Log4j2
            ├── deployment.yaml          # 5 microservice deployments
            ├── ingress.yaml             # Microservice ingresses
            ├── poddisruptionbudgets.yaml # PDBs for all microservices
            ├── rbac.yaml                # ClusterRole for service discovery
            ├── service.yaml             # Microservice services
            └── serviceaccount.yaml      # Service account for microservices
----

=== Sub-Subchart Architecture

The observability subchart uses an advanced **sub-subchart pattern** where each observability component (Grafana, Loki, Prometheus, Tempo, OTel Collector) is its own independent chart. This provides:

* **Component Independence**: Enable/disable individual observability components
* **Simplified Values**: Each sub-subchart has flat value paths (`.Values.config` instead of `.Values.loki.config`)
* **Isolated Testing**: Test and validate each observability component separately
* **Flexible Deployment**: Deploy only the monitoring components you need
* **Cleaner Organization**: 5-6 focused template files per component instead of monolithic files

Example: Disable Loki while keeping other observability components:
[source,bash]
----
helm install spring-load-developme . \
  --set observability.loki.enabled=false \
  --namespace reloading
----

=== Parent Chart Files

* `Chart.yaml` - Parent chart metadata with subchart dependencies
* `values.yaml` - Simplified parent configuration controlling subcharts
* `values-old.yaml` - Original monolithic values (backup, preserved for reference)
* `values.schema.json` - JSON Schema validation
* `.helmignore` - Excludes unnecessary files from packages
* `README.adoc` - This comprehensive documentation
* `templates/_helpers.tpl` - Parent chart helper functions
* `templates/NOTES.txt` - Post-installation instructions
* `Chart.lock` - Dependency lock file (generated by `helm dependency update`, committed to git)

=== Subchart Architecture

The chart is organized into 4 independent subcharts under `charts/`:

==== 1. Observability Subchart (`charts/observability/`)

Complete monitoring and tracing stack using **sub-subchart architecture**:

* `Chart.yaml` - Subchart metadata with 5 sub-subchart dependencies
* `values.yaml` - Enable/disable flags for each observability component
* `templates/_helpers.tpl` - Shared observability helper functions
* `charts/` - Sub-subchart directory containing 5 independent observability components:
** `grafana/` - Grafana visualization (7 templates: _helpers.tpl, ConfigMap, Deployment, Ingress, PDB, PVC, Service)
** `loki/` - Loki log aggregation (6 templates: _helpers.tpl, ConfigMap, Deployment, PDB, PVC, Service)
** `otel-collector/` - OpenTelemetry Collector (5 templates: _helpers.tpl, ConfigMap, Deployment, PDB, Service)
** `prometheus/` - Prometheus metrics (6 templates: _helpers.tpl, ConfigMap, Deployment, PDB, PVC, Service)
** `tempo/` - Tempo distributed tracing (6 templates: _helpers.tpl, ConfigMap, Deployment, PDB, PVC, Service)

**Total: 5 sub-subcharts with 30 template files for complete observability stack**

Each sub-subchart has its own:

* `Chart.yaml` - Component metadata (version 0.1.0-SNAPSHOT with specific appVersion)
* `values.yaml` - Component-specific configuration with flat value paths
* `templates/_helpers.tpl` - Component-specific helper functions
* Resource templates - Deployments, Services, ConfigMaps, PVCs, PDBs as needed

This architecture enables granular control: disable Loki with `--set observability.loki.enabled=false` while keeping Prometheus, Grafana, Tempo, and OTel Collector active.

==== 2. Keycloak Subchart (`charts/keycloak/`)

Authentication and authorization:

* `Chart.yaml` - Subchart metadata
* `values.yaml` - Keycloak configuration (auth, realm, tracing)
* `files/realm.json` - Keycloak realm definition
* `templates/_helpers.tpl` - Keycloak helper functions
* `templates/configmap.yaml` - Keycloak configuration
* `templates/deployment.yaml` - Keycloak deployment with realm import
* `templates/ingress.yaml` - Keycloak ingress
* `templates/poddisruptionbudget.yaml` - Keycloak PDB
* `templates/realm-configmap.yaml` - ConfigMap for realm import
* `templates/secret.yaml` - Keycloak secrets
* `templates/service.yaml` - Keycloak service

**Total: 8 template files + realm configuration**

==== 3. PostgreSQL Subchart (`charts/postgresql/`)

Database services:

* `Chart.yaml` - Subchart metadata
* `values.yaml` - PostgreSQL configuration for both instances
* `templates/_helpers.tpl` - Database helper functions
* `templates/configmap.yaml` - PostgreSQL configuration
* `templates/poddisruptionbudgets.yaml` - PDBs for both databases
* `templates/secret.yaml` - Database credentials
* `templates/service.yaml` - Database services
* `templates/statefulset.yaml` - Two StatefulSets (microservices DB + Keycloak DB)

**Total: 6 template files managing 2 database instances**

==== 4. Reloading Subchart (`charts/reloading/`)

Spring Boot microservices:

* `Chart.yaml` - Subchart metadata
* `values.yaml` - All microservice configurations (API Gateway, Loads, Components, Rifles, MCP Server)
* `templates/_helpers.tpl` - Microservice helper functions with unified generation logic
* `templates/configmaps.yaml` - Application configs (Spring Boot profiles, Log4j2)
* `templates/deployment.yaml` - All 5 microservice deployments using helper templates
* `templates/ingress.yaml` - Microservice ingresses
* `templates/poddisruptionbudgets.yaml` - PDBs for all microservices
* `templates/rbac.yaml` - ClusterRole for service discovery
* `templates/service.yaml` - Microservice services
* `templates/serviceaccount.yaml` - Service account for microservices

**Total: 8 template files managing 5 microservices**

=== Benefits of Subchart Architecture

==== Modularity
* Each subchart is independently developed and tested
* Clear separation of concerns (observability, auth, data, apps)
* Smaller, focused configuration files
* Easier to understand and navigate

==== Flexibility
* Enable/disable entire stacks with a single flag
* Override subchart values without modifying subchart code
* Mix and match components (e.g., use external Keycloak)
* Different teams can own different subcharts

==== Maintainability
* Changes to one subchart don't affect others
* Reduced risk of breaking changes
* Independent versioning of subcharts
* Easier to test components in isolation

==== Reusability
* Subcharts can be used in other projects
* Common patterns (observability, auth) standardized
* Can publish subcharts to Helm repositories
* Share infrastructure patterns across teams

=== Adding a New Microservice

To add a new microservice to the reloading subchart:

*Step 1: Add to charts/reloading/values.yaml*
[source,yaml]
----
newService:
  enabled: true
  replicas: 1
  image:
    repository: zhoozhoo.ca/spring-load-development/new-service
    tag: "latest"
  service:
    type: ClusterIP
    port: 8080
  resources:
    limits: {cpu: 500m, memory: 512Mi}
    requests: {cpu: 250m, memory: 256Mi}
----

*Step 2: Add to charts/reloading/templates/deployment.yaml*
[source,yaml]
----
{{/* New Service Deployment */}}
{{- if .Values.newService.enabled }}
{{- include "reloading.microservice.deployment" (dict "componentName" "new-service" "config" .Values.newService "context" . "needsDatabase" true) }}
{{- end }}
----

*Step 3: Add to charts/reloading/templates/service.yaml*
[source,yaml]
----
{{/* New Service Service */}}
{{- if .Values.newService.enabled }}
{{- include "reloading.microservice.service" (dict "componentName" "new-service" "serviceName" "new-service" "config" .Values.newService "context" .) }}
{{- end }}
----

*Step 4: Add to charts/reloading/templates/poddisruptionbudgets.yaml*
[source,yaml]
----
{{/* New Service PDB */}}
{{- if .Values.newService.enabled }}
{{- include "reloading.microservice.podDisruptionBudget" (dict "componentName" "new-service" "config" .Values.newService "context" .) }}
{{- end }}
----

*Step 5: Update parent values.yaml if needed*
[source,yaml]
----
reloading:
  enabled: true
  newService:
    enabled: true
----

The helper functions in `charts/reloading/templates/_helpers.tpl` automatically generate consistent Deployments and Services.