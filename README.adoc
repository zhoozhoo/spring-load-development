= Spring Load Development image:https://github.com/zhoozhoo/spring-load-development/actions/workflows/github-code-scanning/codeql/badge.svg["CodeQL", link="https://github.com/zhoozhoo/spring-load-development/actions/workflows/github-code-scanning/codeql"] image:https://github.com/zhoozhoo/spring-load-development/actions/workflows/ci.yml/badge.svg["Continuous Integration", link="https://github.com/zhoozhoo/spring-load-development/actions/workflows/ci.yml"]

:author: Zhubin Salehi
:email: zhoozhoo@yahoo.com
:doctype: book

Spring Load Development is a project that demonstrates the integration of various modern technologies and frameworks to build a robust microservices architecture. This project showcases the use of Spring Boot for microservices, Spring WebFlux for reactive RESTful web services, Spring Data R2DBC for reactive database connectivity, Spring Cloud Config for externalized configuration management, Spring Cloud Gateway for API gateway, Resilience4J for circuit breaker patterns, and Spring AI for Model Context Protocol (MCP) server integration.

[NOTE]
====
*Load development* is used here as an example business domain to demonstrate microservices architecture and modern cloud-native patterns. In the context of competitive shooting, load development refers to the process of systematically testing and refining ammunition components (such as powder charge, bullet, primer, and case dimensions) to achieve optimal accuracy and performance for a specific firearm. This project manages and analyzes load development data as a sample use case, but the architecture and patterns are applicable to many other domains.
====

== Technologies and Frameworks Used

* Microservices using link:https://spring.io/projects/spring-boot[Spring Boot]
* Reactive RESTful Web Services using link:https://docs.spring.io/spring-framework/reference/web/webflux.html[Spring WebFlux]
* Reactive Relational Database Connectivity using link:https://spring.io/projects/spring-data-r2dbc[Spring Data R2DBC]
* Externalized Configuration Management using link:https://spring.io/projects/spring-cloud-config[Spring Cloud Config]
* Service Discovery using link:https://spring.io/projects/spring-cloud-netflix[Spring Cloud Netflix] 
* Role-Based Access Control (RBAC) using link:https://spring.io/projects/spring-security[Spring Security] and link:https://www.keycloak.org/[Keycloak]
* API Gateway using link:https://spring.io/projects/spring-cloud-gateway[Spring Cloud Gateway]
* Circuit Breaker using link:https://spring.io/projects/spring-cloud-circuitbreaker[Spring Cloud Circuit Breaker] and link:https://resilience4j.readme.io/docs/getting-started[Resilience4J]
* AI Integration using link:https://spring.io/projects/spring-ai[Spring AI] and Model Context Protocol (MCP)
* Observability and Monitoring using link:https://opentelemetry.io/[OpenTelemetry], link:https://grafana.com/oss/tempo/[Tempo], link:https://grafana.com/oss/loki/[Loki], link:https://prometheus.io/[Prometheus], and link:https://grafana.com/[Grafana]
* Application Monitoring using link:https://github.com/codecentric/spring-boot-admin[Spring Boot Admin]
* Container Orchestration using link:https://kubernetes.io/[Kubernetes] and link:https://helm.sh/[Helm]

[NOTE]
====
All technologies are open source and widely adopted in cloud-native Java ecosystems. Version details can be found in the respective `pom.xml` files.
====

== Getting Started

=== Prerequisites

* Java 25 or later
* Docker and Docker Compose
* Maven 4.0+ (4.0.0-rc-4 or later)
* Kubernetes cluster and kubectl (for Kubernetes deployment)
* Helm 3.0+ (for Helm deployment)

=== Deployment Options

The Spring Load Development application can be deployed in multiple ways:

1. **Docker Compose** - For local development and testing
2. **Kubernetes with Helm** - For production deployment
3. **Manual Spring Boot** - For development debugging

==== Option 1: Docker Compose Deployment (Recommended for Development)

===== Clone the repository:

[source,bash]
----
git clone https://github.com/zhoozhoo/spring-load-development.git
cd spring-load-development
----

===== Build the project:

[source,bash]
----
mvn clean package
----

===== Start all services using Docker Compose:

[source,bash]
----
docker-compose --env-file .env up -d
----

This will start all infrastructure services (PostgreSQL, Keycloak, Grafana, etc.) and the Spring Boot applications.

==== Option 2: Kubernetes Deployment with Helm (Recommended for Production)

===== Install using Helm:

[source,bash]
----
# Add and update helm repo (if using a helm repository)
helm repo update

# Install the application
helm install spring-load-development ./helm/spring-load-development \
  --create-namespace \
  --namespace spring-load-development
----

===== Access services:

[source,bash]
----
# Get service URLs
kubectl get services -n spring-load-development

# For local development, port-forward to access services
kubectl port-forward -n spring-load-development service/spring-loaddev-api-gateway 8080:8080
----

For detailed Helm chart configuration, see link:helm/spring-load-development/README.adoc[Helm Chart Documentation].

==== Option 3: Manual Spring Boot Services (Development/Debugging)

===== Start infrastructure services:

[source,bash]
----
docker-compose --env-file .env up -d postgres keycloak grafana loki tempo prometheus otel-collector
----

===== Start Spring Boot services in order:

[source,bash]
----
# 1. Start Config Server (required by other services)
java -jar spring-loaddev-config-server/target/spring-loaddev-config-server-*.jar

# 2. Start Discovery Server (in a new terminal)
java -jar spring-loaddev-discovery-server/target/spring-loaddev-discovery-server-*.jar

# 3. Start API Gateway (in a new terminal)
java -jar spring-loaddev-api-gateway/target/spring-loaddev-api-gateway-*.jar

# 4. Start microservices (each in a new terminal)
java -jar spring-loaddev-loads-service/target/spring-loaddev-loads-service-*.jar
java -jar spring-loaddev-rifles-service/target/spring-loaddev-rifles-service-*.jar
java -jar spring-loaddev-components-service/target/spring-loaddev-components-service-*.jar
java -jar spring-loaddev-mcp-server/target/spring-loaddev-mcp-server-*.jar

# 5. Start Admin Server (optional, for monitoring)
java -jar spring-loaddev-admin-server/target/spring-loaddev-admin-server-*.jar
----

=== Accessing Services

==== Docker Compose Deployment

Once the services are up and running, you can access them at the following URLs:

* API Gateway: http://localhost:8080
* Keycloak Admin Console: http://localhost:7080
* Grafana Dashboard: http://localhost:3000
* Admin Server: http://localhost:9090

==== Kubernetes Deployment

For Kubernetes deployment, services are accessible via NodePort or port-forwarding:

[source,bash]
----
# Port-forward API Gateway
kubectl port-forward -n spring-load-development service/spring-loaddev-api-gateway 8080:8080

# Port-forward Grafana
kubectl port-forward -n observability service/grafana 3000:3000

# Port-forward Keycloak
kubectl port-forward -n keycloak service/keycloak 7080:8080
----

Alternatively, if using NodePort services, check the assigned ports:

[source,bash]
----
kubectl get services -A | grep NodePort
----

=== AI Integration

The project includes an MCP (Model Context Protocol) server that provides AI-assisted tools for managing loads and rifles:

* Integration with GitHub Copilot through the Model Context Protocol
* AI-assisted load development analysis
* Intelligent rifle configuration recommendations
* Natural language queries for load data

To connect GitHub Copilot to the MCP server, configure the `.vscode/mcp.json` file in your project directory:

[source,json]
----
{
  "servers": {
    "reloading-mcp-server": {
      "type": "sse",
      "url": "http://localhost:8080/sse"
    }
  }
}
----

=== API Documentation

API endpoints are documented using OpenAPI (Swagger). Once services are running, access the documentation at:

http://localhost:8080/swagger-ui.html

Alternatively, use the `.http` files in the top-level `test/` directory with the VS Code REST Client extension for manual testing.  (link:test/README.adoc[API Testing Guide])

=== Services Architecture

The application is composed of the following services:

* *Config Server*: Centralized configuration management for all services
* *Discovery Server*: Service registry and discovery using Eureka
* *API Gateway*: Routes and filters requests to appropriate services
* *Rifles Service*: Manages rifle data and configurations
* *Loads Service*: Handles load development data including groups and shots 
* *Components Service*: Manages reloading components (cases, powders, primers, bullets) for load development
* *MCP Server*: Provides AI-assisted tools via Model Context Protocol for loads and rifles management (link:spring-loaddev-mcp-server/README.adoc[MCP Server Guide])
* *Admin Server*: Monitoring and management of all services

=== Configuration Repository

The centralized configuration for all services is stored in a separate GitHub repository:
https://github.com/zhoozhoo/spring-load-development-config

The Config Server automatically picks up configuration files from this repository at startup.

=== Security

The application uses Keycloak for identity and access management with the following features:

* Role-based access control (RBAC)
* JWT token-based authentication
* OAuth2/OpenID Connect integration
* Predefined roles: RELOADER
* Fine-grained permissions for loads and rifles management

=== Monitoring and Observability

The project includes a comprehensive observability stack with multiple components working together:

==== Spring Boot Admin Server
* Access the Admin Server dashboard at http://localhost:9090
* Monitor application health, metrics, and environment
* View detailed information about each service
* Access actuator endpoints through a user-friendly interface
* Track service status and configurations

==== Observability Stack
The project uses a modern observability stack with:

* **OpenTelemetry Collector**: Centralized collection of telemetry data (traces, logs, metrics)
* **Tempo**: Distributed tracing backend for storing and querying traces
* **Loki**: Log aggregation system for centralized log storage and querying  
* **Prometheus**: Metrics collection and alerting
* **Grafana**: Unified dashboards for visualizing metrics, traces, and logs

Access the observability components at:
* Grafana (unified dashboards): http://localhost:3000
* Prometheus (metrics): http://localhost:9091

==== Monitoring architecture

The diagram below shows the monitoring data flow used by this project. Services export metrics via the Actuator Prometheus endpoint and send telemetry (traces and logs) over OTLP to an OpenTelemetry Collector. The Collector routes traces to Tempo, logs to Loki and can optionally forward metrics or expose them for Prometheus. Prometheus scrapes the Actuator metrics endpoint; Grafana visualizes metrics, traces and logs; Alertmanager handles alerts from Prometheus; Spring Boot Admin provides a quick actuator UI for all services.

[source,mermaid]
....
flowchart LR
    subgraph Services[Services / Applications]
        S1["Microservice"]
    end

    subgraph OTEL[Observability Plane]
        OC["OpenTelemetry Collector"]
        Tempo["Tempo\n(Trace Store)"]
        Loki["Loki\n(Log Store)"]
        Prom["Prometheus"]
        Graf["Grafana"]
    end

    %% Service -> telemetry
    S1 -->|"OTLP (traces)"| OC
    S1 -->|"OTLP (logs)"| OC
    S1 -->|"OTLP (metrics)"| OC

    %% Collector -> backends
    OC -->|"traces"| Tempo
    OC -->|"logs"| Loki
    OC -->|"metrics"| Prom

    %% Visualisation / alerting
    Tempo -->|traces| Graf
    Loki -->|logs| Graf
    Prom -->|metrics| Graf

    classDef serviceStyle fill:#e8f5e8,stroke:#388e3c,stroke-width:2px,color:#000000
    classDef infraStyle fill:#fafafa,stroke:#616161,stroke-width:2px,color:#000000
    
    class S1 serviceStyle
    class OC,Tempo,Loki,Prom,Graf infraStyle
....

This observability architecture shows how all telemetry data (traces, logs, and metrics) is centrally collected by the OpenTelemetry Collector and distributed to specialized backends: Tempo for traces, Loki for logs, and Prometheus for metrics. Grafana provides unified dashboards combining all three data types for comprehensive observability. Spring Boot Admin remains available for quick actuator inspection and service management.

== High-Level Architecture

[source,mermaid]
....
flowchart TB
    subgraph Client[Clients]
        User[User]
        Copilot[GitHub Copilot]
    end

    subgraph Gateway[API Gateway]
        APIGateway[API Gateway<br/>Port: 8080]
    end

    subgraph Services["Microservices"]
        LoadsService[Loads Service]
        RiflesService[Rifles Service]
        ComponentsService[Components Service]
        MCPServer[MCP Server<br/>AI Integration]
    end

    Postgres[(PostgreSQL<br/>Database)]

    subgraph Infrastructure["Infrastructure"]
        Keycloak[Keycloak<br/>Authentication]
        ConfigServer[Config Server<br/>Centralized Config]
        DiscoveryServer[Discovery Server<br/>Service Registry]
    end

    %% Client connections
    User -->|REST API| APIGateway
    User -->|Login| Keycloak
    Copilot -->|MCP Protocol| APIGateway

    %% Gateway to services
    APIGateway --> LoadsService
    APIGateway --> RiflesService
    APIGateway --> ComponentsService
    APIGateway --> MCPServer

    %% AI service integration
    MCPServer -.-> LoadsService
    MCPServer -.-> RiflesService
    MCPServer -.-> ComponentsService


    %% Infrastructure connections (simplified)
    Services -.->|Register| DiscoveryServer
    Services -.->|Configuration| ConfigServer
    Services -.->|Auth| Keycloak
    Services -.->Postgres

    classDef clientStyle fill:#e1f5fe,stroke:#0277bd,stroke-width:2px,color:#000000
    classDef gatewayStyle fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,color:#000000
    classDef serviceStyle fill:#e8f5e8,stroke:#388e3c,stroke-width:2px,color:#000000
    classDef dataStyle fill:#fff3e0,stroke:#f57c00,stroke-width:2px,color:#000000
    classDef infraStyle fill:#fafafa,stroke:#616161,stroke-width:2px,color:#000000

    class User,Copilot clientStyle
    class APIGateway gatewayStyle
    class LoadsService,RiflesService,ComponentsService,MCPServer serviceStyle
    class Postgres dataStyle
    class ConfigServer,DiscoveryServer,Keycloak infraStyle
....

== Database Schema

[source,mermaid]
....
erDiagram
    LOADS {
        BIGSERIAL id PK
        VARCHAR(255) owner_id NOT NULL
        VARCHAR(255) name NOT NULL
        TEXT description
        VARCHAR(32) measurement_units NOT NULL "CHECK (Imperial, Metric)"
        VARCHAR(255) powder_manufacturer NOT NULL
        VARCHAR(255) powder_type NOT NULL
        VARCHAR(255) bullet_manufacturer NOT NULL
        VARCHAR(255) bullet_type NOT NULL
        DOUBLE_PRECISION bullet_weight NOT NULL
        VARCHAR(255) primer_manufacturer NOT NULL
        VARCHAR(255) primer_type NOT NULL
        DOUBLE_PRECISION distance_from_lands
        DOUBLE_PRECISION case_overall_length
        DOUBLE_PRECISION neck_tension
        BIGSERIAL rifle_id FK
    }
    GROUPS {
        BIGSERIAL id PK
        VARCHAR(255) owner_id NOT NULL
        BIGSERIAL load_id FK NOT NULL
        DATE date NOT NULL
        DOUBLE_PRECISION powder_charge NOT NULL
        INTEGER target_range NOT NULL
        DOUBLE_PRECISION group_size
    }
    SHOTS {
        BIGSERIAL id PK
        VARCHAR(255) owner_id NOT NULL
        BIGSERIAL group_id FK NOT NULL
        INTEGER velocity
    }
    RIFLES {
        BIGSERIAL id PK
        VARCHAR(255) owner_id NOT NULL
        VARCHAR(255) name NOT NULL
        TEXT description
        VARCHAR(32) measurement_units NOT NULL "CHECK (Imperial, Metric)"
        VARCHAR(32) caliber NOT NULL
        DOUBLE_PRECISION barrel_length
        VARCHAR(32) barrel_contour
        VARCHAR(32) twist_rate
        VARCHAR(32) rifling
        DOUBLE_PRECISION free_bore
    }
    BULLETS {
        BIGSERIAL id PK
        VARCHAR(255) owner_id NOT NULL
        VARCHAR(255) manufacturer NOT NULL
        DOUBLE_PRECISION weight NOT NULL
        VARCHAR(255) type NOT NULL
        VARCHAR(255) measurement_units NOT NULL
        DECIMAL(10) cost NOT NULL
        VARCHAR(3) currency NOT NULL
        INTEGER quantity_per_box NOT NULL
        TSVECTOR search_vector
    }
    POWDERS {
        BIGSERIAL id PK
        VARCHAR(255) owner_id NOT NULL
        VARCHAR(255) manufacturer NOT NULL
        VARCHAR(255) type NOT NULL
        VARCHAR(255) measurement_units NOT NULL
        DECIMAL(10) cost
        VARCHAR(3) currency
        DOUBLE_PRECISION weight_per_container
        TSVECTOR search_vector
    }
    PRIMERS {
        BIGSERIAL id PK
        VARCHAR(255) owner_id NOT NULL
        VARCHAR(255) manufacturer NOT NULL
        VARCHAR(255) type NOT NULL
        VARCHAR(20) size NOT NULL
        DECIMAL(10) cost NOT NULL
        VARCHAR(3) currency NOT NULL
        INTEGER quantity_per_box NOT NULL
        TSVECTOR search_vector
    }
    CASES {
        BIGSERIAL id PK
        VARCHAR(255) owner_id NOT NULL
        VARCHAR(255) manufacturer NOT NULL
        VARCHAR(50) caliber NOT NULL
        VARCHAR(20) primer_size NOT NULL
        DECIMAL(10) cost NOT NULL
        VARCHAR(3) currency NOT NULL
        INTEGER quantity_per_box NOT NULL
        TSVECTOR search_vector
    }
    %% Relationships
    LOADS ||--o{ GROUPS : "has"
    GROUPS ||--o{ SHOTS : "has"
    RIFLES ||--o{ LOADS : "uses"
....

== TODO

* [ ] Upgrade to Spring AI 1.1.0
* [ ] Update MCP server to support resources and prompts
* [ ] Add brass case attributes such as neck tension, headspace, etc.
* [ ] Implement load comparison and analysis tools
* [ ] Add shooting session tracking and analytics

== License

This project is licensed under the Apache License 2.0 - see the LICENSE file for details.
